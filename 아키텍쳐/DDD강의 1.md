## DDD 강의 첫날
- 강사 박재성

### 기존 개발
- 데이터 종속적인 애플리케이션
- 데이터베이스 위주의 개발 (데이터베이스 모델링을 중요시)
- 데이터베이스 스키마가 정해지면 모든 코드가 정해진다.
- 모델링과 개발과의 불일치 발생
- 불일치는 불필요한 해석 과정을 야기하고, 이는 잘못된 소프트웨어를 만드는 원인이 되기도 한다.
- 개발자들은 자신의 개발력을 훈련할 수 있는 정량적 문제를 좋아한다.

### 도메인 주도 설계
- 이런 불일치를 해소하기 위한 노력 중 하나가 바로 DDD(Domain-Driven Design)
- Eric Evans의 동명의 책에서 유래
- 도메인 모델의 적용 범위를 구현까지 확장하여 도메인 지식을 구현 코드에 반영
- 공통의 언어(유비쿼터스 언어)를 사용하여 도메인과 구현을 충분히 만족하는 모델을 만든다.
- 실제 코드로 구현 가능한 현실성 있는 도메인 모델 분석과 그것을 추상화하는 설계
- "설계를 하라, 그 다음에 구축하라"가 아니다.
- 다양한 원칙과 패턴

### 전략적 설계 / 전술적 설계
- 진정한 DDD는 전략적 설계가 중요
- 이번 강의에서는 전술적 설계를 다룰 예정

### 도메인
- 소프트웨어가 해결하고자 하는 문제 영역
- 일반적인 요구사항, 전문 용어, 그리고 컴퓨터 프로그래밍 분야에서 문제를 풀기 위해 설계된 어떤 소프트웨어 프로그램에 대한 기능성을 정의하는 연구의 한 영역

### 도메인 모델
- 특정 도메인을 개념적으로 표현한 것
- 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는 데 도움이 된다.
- 모델의 각 구성 요소는 특정 도메인을 한정할 때 비로소 의미가 완전해지기 때문에, 각 하위 도메인마다 별도로 모델을 만들어야 한다.

### 네개의 레이어
- 표현 영역 또는 UI 영역은 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다.
- 응용 영역은 시스템이 사용자에게 제공해야 할 기능을 구현한다.
- 도메인 영역은 도메인 모델을 구현한다.
- 인프라스트럭처 영역은 구현 기술에 대한 것을 다룬다.

## 도메인 주도 설계 기본요소

### 엔티티와 밸류오브젝트
- 도출한 모델은 크게 엔티티(Entity)와 밸류오브젝트(Value Object)로 구분
- 데이터와 함께 도메인 기능을 제공한다.

### Entity
- 식별자를 갖는다.
- 식별자는 엔티티 객체마다 고유해서 각 엔티티는 서로 다른 식별자를 갖는다.
- 식별자 생성
    - 특정 규칙에 따라 생성
    - UUID 사용
    - 값을 직접 입력
    - 일련번호 사용(시퀀스나 DB의 자동 증가 칼럼 사용)

### 도메인 모델에 set 메서드 넣지 않기
- 도메인 모델에 get/set 메서드를 무조건 추가하는 것은 좋지 않은 버릇
- 특히 set 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
- set 메서드의 또 다른 문제는 도메인 객체를 생성할 때 완전한 상태가 아닐 수도 있다는 것이다.
- 도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 **생성 시점에 필요한 것을 전달해 주어야 한다.**
~~~ java
changeShippingInfo() vs setShippingInfo()
completePayment() vs setOrderState()
~~~

### 밸류 오브젝트(value object)
- 밸류 타입은 불변
- 의미를 명확하게 표현하거나 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용
- 시스템이 성숙함에 따라 데이터 값을 객체로 대체
- 밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것뿐이다.
- 정말 String으로 우편 번호를 표현할 수 있는가?
- 항상 equals() 메서드를 오버라이드할 것을 권고한다.
> equals를 재정의하려거든 hashCode도 재정의하라 - Effective Java

### vo 와 dto
- vo는 어플리케이션 내부의 요구사항이고 dto는 어플리케이션 외부의 요구사항이다.

### Aggregate
- 관련 객체를 하나로 묶은 군집
- 애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다.
- 애그리거트로 묶어서 바라보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
- 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
- 두 개 이상의 엔티티로 구성되는 애그리거트는 드물게 존재한다.

### 애그리거트 루트
- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.
- 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
- 이는 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화할 수 있도록 돕는다.
- 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.

### 애그리거트 참조
- 애그리거트를 직접 참조할 때 발생할 수 있는 가장 큰 문제는 편리함을 오용할 수 있다.
- ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다,
- ID를 이용한 참조 방식을 사용하면 복잡도를 낮추는 것과 함께 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 원천적으로 방지할 수 있다.

### 직접 참조와 간접참조
- 객체를 가지고 있느냐 Id값만 가지고 있느냐
- 강한의존을 끊는게 간접 참조

### Repository
- 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델
- 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.
- 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.
- 리포지터리가 완전한 애그리거트를 제공하지 않으면, 필드나 값이 올바르지 않아 애그리거트의 기능을 실행하는 도중에 NullPointerException과 같은 문제가 발생하게 된다.
- 리포지토리는 애그리거트(루트) 단위로 존재하며 테이블 단위로 존재하는 것이 아니다.

~~~ java
public interface OrderRepository {
    public Order findByNumber(OrderNumber number);
    public void save(Order order);
    public void delete(Order order);
}
~~~

### 도메인 서비스
- 한 애그리거트에 넣기 애매한 도메인 개념을 구현하려면 애그리거트에 억지로 넣기보다는 도메인 서비스를 이용해서 도메인 개념을 명시적으로 드러내면 된다.
- 응용 영역의 서비스가 용용 로직을 다룬다면 도메인 서비스는 도메인 로직을 다룬다.
- 도메인 영역의 애그리거트나 밸류와 같은 다른 구성요소와 비교할 때 다른 점은 상태 없이 로직만 구현한다.
- 서비스를 사용하는 주체는 애그리거트가 될 수도 있고 응용 서비스가 될 수도 있다.
- 애그리거트 메서드를 실행할 때 도메인 서비스를 인자로 전달하지 않고 반대로 도메인 서비스의 기능을 실행할 때 애그리거트를 전달하기도 한다.
- 특정 기능이 응용 서비스인지 도메인 서비스인지 감을 잡기 어려울 때는 해당 로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태 값을 계산하는지 검사해 보면 된다.

### 팩토리
- 어떤 객체를 생성하는 일이 복잡하다면 FACTORY를 이용해 이것을 캡슐화할 수 있다.
- 생성자, 팩토리 클래스
- 연관된 애그리거트에서 생성해 보자.
- 어떤 다른 곳에서 해당 객체를 생성할 때 생산자의 정보를 필요로 하는 것을 줄일 수 있다.
- 아울러 생산자와 생성된 객체 사이의 특별한 관계를 전해주기도 합니다.

### 모듈
- = 패키지
- 계층 우선 vs 기능 우선
~~~ txt
+-- application
+-- domain
+-- infra
+-- ui
~~~
~~~ txt
+-- item
+-- pokemon
+-- trainer
~~~

### Bounded Context
- **Root Aggregate의 그룹을 bounded Context라고 볼 수 있다.**
- 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다.
- 하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야 한다.
- 모델은 특정한 컨텍스트(문맥)하에서 완전한 의미를 갖는다.
- 이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 BOUNDED CONTEXT라고 부른다.

### 좋은 Bounded Context
- 하나의 BOUNDED CONTEXT는 하나의 팀에만 할당되어야 한다.
    - 하나의 팀은 여러 개의 BOUNDED CONTEXT를 다룰 수 있다.
- 각각의 BOUNDED CONTEXT는 각각의 개발 환경을 가질 수 있다.


### CONTEXT MAP
- 컨텍스트 맵은 상호 교류하는 시스템의 목록을 제공하고, 팀 내 의사소통의 촉매 역할을 한다.

### DDD vs OOP
- OOP는 상속이나 재활용성을 위해서 공통된 데이터를 공유하는 것을 중요시
- DDD는 도메인 분리를 중시
~~~ txt
언급하셨다시피, DDD의 진정한 힘은 유비쿼터스 언어와 BOUNDED CONTEXT부터 시작합니다.
유비쿼터스 언어를 반영해야 전술적 설계가 의미가 있는 셈이죠.
OOP에 근간하지만 OOP 원칙을 정면으로 위배하는 패턴도 몇 있어요.
예를 들어 ID를 이용해서 애그리거트 간 decoupling을 시킨다든지,
도메인 서비스는 행동을 객체에서 의도적으로 분리시키는 패턴이 OOP와는 다른 개념입니다.
밸류 타입을 사용하는 것을 권장하는 등,
저는 DDD의 전술적 설계가 순수 OOP보다 더 적용하기 심플한 측면이 있다고 개인적으로 생각해요.
~~~

## 참조
https://raindrop.dooray.com/share/posts/-Fny78YURpKKPjMUgpaD6w